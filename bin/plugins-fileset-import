#!/bin/sh

TAG_FROM_FILENAME=no
OWNER_AS_PARENT_FOLDER=no

while getopts "f:p:c:to" option
do
        case $option
        in
                f) TARGET_FILESET_AREA=${OPTARG};;
                p) PLUGINS_DIR=${OPTARG};;
                c) MATCHING_CONFIG=${OPTARG};;
                t) TAG_FROM_FILENAME=yes;;
                o) OWNER_AS_PARENT_FOLDER=yes;;
                \?) echo "Invalid option: $OPTARG" >&2; exit 1;;
                :) echo "Option ${option} requires an argument." >&2; exit 1;;
        esac
done


#read the list of input files from the remaining command line parameters
let --OPTIND
shift $OPTIND
declare -a FILES=("$@")
declare -i i
FILES=("$@")

echo number of files to push ${#FILES[@]}


create_registration_info() {
    for ((i=0; $i < ${#FILES[@]}; ++i))
    do
        unset value
	    echo Checking file: ${FILES[$i]}
	
	    if [ ${OWNER_AS_PARENT_FOLDER} == "yes" ]
        then
		    #extract the OWNER from the parent directory
            OWNER=$(expr `dirname ${FILES[$i]}` : '.*/\([^/]*\)$')
	    else
		    #get the owner from the grandparent directory
		    OWNER=$(expr `dirname ${FILES[$i]}` : '.*/\([^/]*\)/[^/]*$')
	    fi	
	
        #extract TAG from filename if requested
        if [ ${TAG_FROM_FILENAME} == "yes" ]
        then
	        TAG=$(expr `basename ${FILES[$i]}` : '\(.\{7\}\).*$')
            TAG_OPTION="--tag ${TAG}"
        else
            TAG_OPTION=
        fi

        #extract the basename from filename
        BASENAME=$(expr `basename ${FILES[$i]}` : '\(.*\)\..*$')

        #get the previous value from the map, if any
        get "files" "${BASENAME}"

        #concatenate the file to the previous list of files
        put "files" "${BASENAME}" "${value} ${FILES[$i]}"

        put "options" "${BASENAME}" "${TAG_OPTION} --owner ${OWNER}"
    done
}


output_commands() {
    NOW=`date "+%Y-%m-%d-%H%M%S"`
    OUTPUT_FILE="import-commands-${NOW}.sh"
    echo "Generating output commands in ${OUTPUT_FILE}..."
    echo "#!/bin/sh" > $OUTPUT_FILE
    getKeySet "files"
    for KEY in $keySet
    do
      get "files" $KEY
      FILES_TO_REGISTER=${value}
      get "options" $KEY
      REGISTRATION_OPTIONS=${value}
      echo "plugins-register-fileset --fileset-area ${TARGET_FILESET_AREA} --plugins-dir ${PLUGINS_DIR} ${REGISTRATION_OPTIONS} ${MATCHING_CONFIG}: ${FILES_TO_REGISTER}" >> $OUTPUT_FILE
      echo "" >> $OUTPUT_FILE
    done
    chmod 777 $OUTPUT_FILE
    echo "done"
}

# store a new key in a map, if the map is simulated, it does not need to be created
# parameters: mapname, key, value
put() {
    if [ "$#" != 3 ]; then exit 1; fi
    mapName=$1; key=$2; value=`echo $3 | sed -e "s/ /:SP:/g"`
    eval map="\"\$$mapName\""
    map="`echo "$map" | sed -e "s/--$key=[^ ]*//g"` --$key=$value"
    eval $mapName="\"$map\""
}

# get the value associated to the given key in the map
# parameters: mapname, key
# return: the value of the key in the $value variable
get() {
    mapName=$1; key=$2; valueFound="false"

    eval map=\$$mapName

    for keyValuePair in ${map};
    do
        case "$keyValuePair" in
            --$key=*) value=`echo "$keyValuePair" | sed -e 's/^[^=]*=//'`
                      valueFound="true"
        esac
        if [ "$valueFound" == "true" ]; then break; fi
    done
    value=`echo $value | sed -e "s/:SP:/ /g"`
}

# get all the keys in the map
# parameters: mapname
# return: the list of keys is returned in the $keySet variable
getKeySet() {
    if [ "$#" != 1 ];
    then
        exit 1;
    fi

    mapName=$1;

    eval map="\"\$$mapName\""

    keySet=`
           echo $map |
           sed -e "s/=[^ ]*//g" -e "s/\([ ]*\)--/\1/g"
          `
}

create_registration_info
output_commands


